# 执行上下文

执行上下文,可以简单理解为函数 __执行时__ 的环境,常见的执行上下文分为三种:

1. 全局上下文 : 默认代码运行环境,JS引擎最先进入该运行环境
2. 函数上下文 : 每当调用一个函数时创建

根据运行栈模型,每个函数调用都会在运行栈中push一个对应的上下文,函数调用返回时,会将上下文pop出栈.上下文中包括以下内容:

1. VariableObject : 调用参数、函数内部声明的变量、函数内部声明的函数
2. 作用域链
3. this

下面代码和注释简单介绍了执行上下文在代码运行过程中入栈、出栈的情况(注释1),以及一个执行上下文的基本结构(注释2):

```javascript
// 0. Js 引擎运行开始
var v = 'v';
var v2 = 'v2';

function Foo() {
    console.log('Foo v:' + v);
    console.log('Foo v2:' + v2);
    v = 'Foo';
    v2 = 'Foo';
}

function Bar(fn) {

    console.log(typeof Bar_fn);
    console.log(typeof Bar_fn2);

    var v = 'Bar';

    function Bar_fn() {
        console.log('Bar_fn v:' + v);
        v = 'Bar_fn';
    }
    var Bar_fn2;
    Bar_fn2 = function() {
        console.log('Bar_fn2 v2:' + v2);
        v2 = 'Bar_fn2';
    }

    fn(); // 2. 开始执行 fn()
    Bar_fn(); // 3. 开始执行 Bar_fn()
    Bar_fn2(); // 4. 开始执行 Bar_fn2()

    Bar_fn = 'string';

    console.log(typeof Bar_fn);
}

Bar(Foo, 'useless'); // 1. 开始执行Bar()
// 5. Bar()执行完...
console.log('v:' + v);
console.log('v2:' + v2);


/*
    0. Js 引擎运行开始,只有全局上下文
    ┌──────────────────────────────────────┐
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Global         │  │
    │  └────────────────────────────────┘  │
    └──────────────────────────────────────┘
    1. 开始执行 Bar(),ECStack.push(ExecuteContext Bar)
    ┌──────────────────────────────────────┐
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Bar            │  │
    │  └────────────────────────────────┘  │
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Global         │  │
    │  └────────────────────────────────┘  │
    └──────────────────────────────────────┘
    2. 开始执行 fn(),ECStack.push(ExecuteContext fn)
    ┌──────────────────────────────────────┐
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext fn             │  │
    │  └────────────────────────────────┘  │
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Bar            │  │
    │  └────────────────────────────────┘  │
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Global         │  │
    │  └────────────────────────────────┘  │
    └──────────────────────────────────────┘
    2. fn 返回,ESStac.pop();
    3. 开始执行 Bar_fn(),push Bar_fn 的ExecuteContext(fn已经退出,Bar并未返回)
    ┌──────────────────────────────────────┐
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Bar_fn         │  │
    │  └────────────────────────────────┘  │
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Bar            │  │
    │  └────────────────────────────────┘  │
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Global         │  │
    │  └────────────────────────────────┘  │
    └──────────────────────────────────────┘
    3. Bar_fn 返回,ESStac.pop();
    4. 开始执行 Bar_fn2(),push Bar_fn2 的ExecuteContext(fn,Bar_fn已经退出,Bar并未返回)
    ┌──────────────────────────────────────┐
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Bar_fn2        │  │
    │  └────────────────────────────────┘  │
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Bar            │  │
    │  └────────────────────────────────┘  │
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Global         │  │
    │  └────────────────────────────────┘  │
    └──────────────────────────────────────┘
    4. Bar_fn2 返回,ESStac.pop();
    ┌──────────────────────────────────────┐
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Bar            │  │
    │  └────────────────────────────────┘  │
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Global         │  │
    │  └────────────────────────────────┘  │
    └──────────────────────────────────────┘
    5. Bar 返回,ESStac.pop();
    ┌──────────────────────────────────────┐
    │  ┌────────────────────────────────┐  │
    │  │  ExecuteContext Global         │  │
    │  └────────────────────────────────┘  │
    └──────────────────────────────────────┘
*/

/* Bar 的 Execute Context 结构类似下面
{
    VO: {
        arguments: {
            0: Foo,
            1: 'useless',
            length: 2
        },
        fn: Foo, // 参数
        v, // 声明的变量
        Bar_fn2, // 声明的变量(var可以变量提升) 但此时还未执行赋值语句
        Bar_fn: function() {...} //通过function创建的函数变量,与Bar_fn2有所不同,创建VO时候就声明并赋值了
    }
    this : {}, // this
    Scope : [] // 作用域链
}
*/
```

函数的执行可以分为以下步骤:

1. Push ExecuteContext
   * VO : A.arguments B.形参 C.函数声明(function xxx(){}) D.变量声明(var xxx); *变量提升就发生在这一阶段*
   * this
   * 作用域链
2. 执行代码:代码执行过程中,可以随时读取&修改 VO 中的对象,
   * 执行到let const声明语句时,let const 声明变量添加到 VO 中
   * 执行到赋值语句时,在VO中通过var声明的变量被赋值
